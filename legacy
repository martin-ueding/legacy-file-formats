#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2012 Martin Ueding <dev@martin-ueding.de>

import optparse
import os

# Dict of file extensions that should be checked. The full name is for the
# stats output. The second element in the details tuple is a list of
# alternative file formats that satisfy the export as well.
patterns = {
    "cdr": ("Corel Draw", ["pdf", "svg"]),
    "doc": ("Microsoft Word", ["pdf", "odt", "txt"]),
    "docx": ("Microsoft Word", ["pdf", "odt", "txt"]),
    "indd": ("Adobe InDesign", ["pdf"]),
    "key": ("Apple Keynote", ["pdf", "odp"]),
    "mindnode": ("Mindnode Mindmap", ["pdf"]),
    "mw": ("Maple Worksheet", ["pdf"]),
    "nb": ("Mathematica Notebook", ["pdf"]),
    "numbers": ("Apple Numbers", ["pdf", "csv", "ods"]),
    "odg": ("OpenOffice Draw", ["pdf"]),
    "odp": ("OpenOffice Impress", ["pdf"]),
    "ods": ("OpenOffice Calc", ["pdf", "csv"]),
    "odt": ("OpenOffice Writer", ["pdf"]),
    "pages": ("Apple Pages", ["pdf"]),
    "ppsx": ("Microsoft PowerPoint", ["pdf"]),
    "ppt": ("Microsoft PowerPoint", ["pdf"]),
    "ppts": ("Microsoft PowerPoint", ["pdf"]),
    "pptx": ("Microsoft PowerPoint", ["pdf"]),
    "psd": ("Adobe Photoshop", ["png", "tiff", "tif"]),
    "rtfd": ("Rich Text Format Directory", ["pdf", "txt", "rtf"]),
    "webarchive": ("Safari Web Archive", ["pdf", "html"]),
    "xcf": ("GIMP Image", ["png", "tiff", "tif"]),
    "xls": ("Microsoft Excel", ["pdf", "csv"]),
    "xlsx": ("Microsoft Excel", ["pdf", "csv"]),
    "xoj": ("Xournal", ["pdf"])
}


def main():
    parser = optparse.OptionParser(usage="legacy [paths...]", description="Checks for proprietary or legacy file formats that do not have a PDF (or similarly standard) exported.")
    parser.add_option("--stat", dest="stat", action="store_true", default=False, help="Print file type summary. [default %default]")
    parser.add_option("--time", dest="time", action="store_true", default=False, help="Check that export is newer than other file. [default %default]")

    (options, args) = parser.parse_args()
    del parser

    # If no directory was given on the command line, use the current working
    # directory.
    if len(args) == 0:
        args.append(".")

    counts = {}

    # Iterate through all given folders.
    for arg in args:
        if os.path.isdir(arg):
            os.path.walk(arg, checkfolder, (options, counts))

    # Print the summary if desired.
    if options.stat:
        print_summary(counts)


def checkfolder(args, dirname, names):
    """
    Checks a folder for files that lack an export.

    In case `file.old` does not have a `file.old.pdf`, a `file.pdf` is checked
    alternatively. It the latter is found, it is moved to `file.old.pdf` to
    show that it is just an export of the original file, not a file on its own.
    """

    options, counts = args

    names.sort()

    # Iterate thorugh all the files and folders.
    for name in names:
        for pattern in patterns:
            if name.lower().endswith("."+pattern):
                # This is the standard export file name.
                exportfile = dirname+"/"+name+"."+options.suffix

                is_invalid = True

                # Check whether the file has the same name, but just a export
                # extension.  Rename the file then.
                if not os.path.isfile(exportfile):
                    alt_exportfile = dirname+"/"+os.path.splitext(name)[0]+"."+options.suffix
                    if os.path.isfile(alt_exportfile):
                        os.rename(alt_exportfile, exportfile)

                # Check for the file again. This time, see whether its
                # modification time is newer than the original, if that option
                # is specified.
                if os.path.isfile(exportfile):
                    if options.time:
                        origtime = os.path.getmtime(dirname+"/"+name)
                        exporttime = os.path.getmtime(exportfile)

                        # If the export is newer than the origtime, the file is
                        # valid.
                        if exporttime > origtime:
                            is_invalid = False
                    else:
                        is_invalid = False

                # Neither the regular nor the alternative export file exists,
                # list this file.
                if is_invalid:
                    print dirname+"/"+name

                    if not pattern in counts:
                        counts[pattern] = 0

                    counts[pattern] += 1


def print_summary(counts):
    if len(counts) == 0:
        return

    print
    for key in sorted(counts):
        print str(counts[key]).rjust(4), key.ljust(10), patterns[key][0]


if __name__ == "__main__":
	main()
